version: "3.7"
services:
   sshserver:
      environment:
         - DEBUG=${DEBUG:?"DEBUG not set"}
         - MAINTENANCE_ENABLED=${MAINTENANCE_ENABLED:?MAINTENANCE_ENABLED not set}
         - REDIS_KEY=${REDIS_KEY:?REDIS_KEY not set}
      build:
         context: ./ssh-wrapper
         args:
             SSH_TO_WEB_KEY: ${SSH_TO_WEB_KEY:?SSH_TO_WEB_KEY not set}
{% if not testing %}
      ports:
         - "${SSH_HOST_PORT:?SSH_HOST_PORT not set}:4444"
{% endif %}
      networks:
         - ssh-and-host
         - web-and-ssh
         - ssh-and-redis

{% if not testing %}
   pgadmin:
      image: dpage/pgadmin4
      environment:
         - PGADMIN_DEFAULT_EMAIL=admin@admin.de
         - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD:?PGADMIN_DEFAULT_PASSWORD not set}
      ports:
         - ${PGADMIN_HTTP_PORT:?PGADMIN_HTTP_PORT not set}:80
      networks:
         - db-and-pgadmin
{% endif %}

   db:
      image: postgres
      restart: always
      volumes:
         - ./data/postgresql-db:/var/lib/postgresql/data
      environment:
         - POSTGRES_USER=ref
         - POSTGRES_DB=ref
         - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?POSTGRES_PASSWORD not set}
      networks:
         - web-and-db
         - db-and-pgadmin

   web:
      security_opt:
         #Needed for mounting overlay inside containers
         - apparmor:unconfined
      environment:
         - SSH_TO_WEB_KEY=${SSH_TO_WEB_KEY:?SSH_TO_WEB_KEY not set}
         - DEBUG=${DEBUG:?DEBUG not set}
         - MAINTENANCE_ENABLED=${MAINTENANCE_ENABLED:?MAINTENANCE_ENABLED not set}
         - REDIS_URL=redis://redis
         - POSTGRES_USER=ref
         - POSTGRES_DB=ref
         - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?POSTGRES_PASSWORD not set}
         - SECRET_KEY=${SECRET_KEY:?SECRET_KEY not set}
         - REDIS_KEY=${REDIS_KEY:?REDIS_KEY not set}
      cap_add:
         - SYS_ADMIN
      build:
         context: ./webapp
         args:
            #Pass the hosts docker group id, since we are using the docker socket from the host.
            DOCKER_GROUP_ID: ${DOCKER_GROUP_ID:?DOCKER_GROUP_ID not set}
      volumes:
         #Persistance folder (db, templates, ...)
         #The mounts need to be propageted, thus we can mount mounts created
         #in this container from the host into other containers
         - type: bind
{% if not testing %}
           source: ./data
{% else %}
           source: ./data-testing
{% endif %}
           target: /data
           bind:
             propagation: shared
         #The webinterface, only needed for live updating during development
         - ./webapp/:/app:ro
         #The exercise templates to import
         - ./exercises/:/exercises:ro
         #Make docker availabe inside the container
         - /var/run/docker.sock:/var/run/docker.sock
{% if not testing %}
      ports:
         - "${HTTP_HOST_PORT}:8000"
{% endif %}
      networks:
         - web-host
         - web-and-ssh
         - web-and-db
         - web-and-redis

   redis:
      image: 'bitnami/redis:5.0'
      environment:
         - REDIS_PASSWORD=${REDIS_KEY:?REDIS_KEY not set}
         - REDIS_DISABLE_COMMANDS=FLUSHDB,FLUSHALL
      volumes:
         - './data/redis-db:/bitnami/redis/data'
      networks:
         - web-and-redis
         - ssh-and-redis

# volumes:
#    redis_data:
#       driver: local

networks:
   #Network used to connect the webinterface to the host
   web-host:
      driver: bridge
      driver_opts:
         com.docker.network.bridge.name: "brref-webhost{{ 't' if testing }}"
   #Webinterface between the SSH entry server and the webinterface.
   #This interface is used by the SSH server to retrive information
   #on how a incoming connection should be routed.
   web-and-ssh:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-webtossh{{ 't' if testing }}"
   #This network connects the SSH entry server to the host.
   ssh-and-host:
      driver: bridge
      driver_opts:
         com.docker.network.bridge.name: "brref-sshhost{{ 't' if testing }}"
   #Connect web to postgres
   web-and-db:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-webtodb{{ 't' if testing }}"
   #connect pgadmin to postgres
   db-and-pgadmin:
      driver: bridge
      driver_opts:
         com.docker.network.bridge.name: "brref-dbtopg{{ 't' if testing }}"
   web-and-redis:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-webtor{{ 't' if testing }}"
   ssh-and-redis:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-sshtor{{ 't' if testing }}"
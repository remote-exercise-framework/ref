version: "3.7"
services:
   sshserver:
      environment:
         - DEBUG=${DEBUG:?"DEBUG not set"}
         - MAINTENANCE_ENABLED=${MAINTENANCE_ENABLED:?MAINTENANCE_ENABLED not set}
         - REDIS_KEY=${REDIS_KEY:?REDIS_KEY not set}
      build:
         context: ./ssh-wrapper
         args:
             SSH_TO_WEB_KEY: ${SSH_TO_WEB_KEY:?SSH_TO_WEB_KEY not set}

      networks:
         - ssh-and-host
         - web-and-ssh
         - ssh-and-redis



   db:
      image: postgres
      restart: always

      environment:
         - POSTGRES_USER=ref
         - POSTGRES_DB=ref
         - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?POSTGRES_PASSWORD not set}
      networks:
         - web-and-db
         - db-and-pgadmin

   web:
      security_opt:
         #Needed for mounting overlay inside containers
         - apparmor:unconfined
      environment:
         - ADMIN_PASSWORD=${ADMIN_PASSWORD:?ADMIN_PASSWORD not set}
         - SSH_TO_WEB_KEY=${SSH_TO_WEB_KEY:?SSH_TO_WEB_KEY not set}
         - DEBUG=${DEBUG:?DEBUG not set}
         - TESTING=1
         - MAINTENANCE_ENABLED=${MAINTENANCE_ENABLED:?MAINTENANCE_ENABLED not set}
         - REDIS_URL=redis://redis
         - POSTGRES_USER=ref
         - POSTGRES_DB=ref
         - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?POSTGRES_PASSWORD not set}
         - SECRET_KEY=${SECRET_KEY:?SECRET_KEY not set}
         - REDIS_KEY=${REDIS_KEY:?REDIS_KEY not set}
      cap_add:
         - SYS_ADMIN
      build:
         context: ./webapp
         args:
            #Pass the hosts docker group id, since we are using the docker socket from the host.
            DOCKER_GROUP_ID: ${DOCKER_GROUP_ID:?DOCKER_GROUP_ID not set}
      volumes:
         #Persistance folder (db, templates, ...)
         #The mounts need to be propageted, thus we can mount mounts created
         #in this container from the host into other containers
         - type: bind
           source: ./data-testing
           target: /data
           bind:
             propagation: shared
         #The webinterface, only needed for live updating during development
         - ./webapp/:/app
         #The exercise templates to import
         - ./exercises-testing:/exercises
         #Make docker availabe inside the container
         - /var/run/docker.sock:/var/run/docker.sock

      networks:
         web-host:
            aliases:
               - "ref.localhost"
         web-and-ssh:
         web-and-db:
         web-and-redis:

   redis:
      image: 'bitnami/redis:5.0'
      environment:
         - REDIS_PASSWORD=${REDIS_KEY:?REDIS_KEY not set}
         - REDIS_DISABLE_COMMANDS=FLUSHDB,FLUSHALL

      networks:
         - web-and-redis
         - ssh-and-redis

# volumes:
#    redis_data:
#       driver: local

networks:
   #Network used to connect the webinterface to the host
   web-host:
      driver: bridge
      driver_opts:
         com.docker.network.bridge.name: "brref-webhostt"
   #Webinterface between the SSH entry server and the webinterface.
   #This interface is used by the SSH server to retrive information
   #on how a incoming connection should be routed.
   web-and-ssh:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-webtossht"
   #This network connects the SSH entry server to the host.
   ssh-and-host:
      driver: bridge
      driver_opts:
         com.docker.network.bridge.name: "brref-sshhostt"
   #Connect web to postgres
   web-and-db:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-webtodbt"
   #connect pgadmin to postgres
   db-and-pgadmin:
      driver: bridge
      driver_opts:
         com.docker.network.bridge.name: "brref-dbtopgt"
   web-and-redis:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-webtort"
   ssh-and-redis:
      driver: bridge
      internal: true
      driver_opts:
         com.docker.network.bridge.name: "brref-sshtort"